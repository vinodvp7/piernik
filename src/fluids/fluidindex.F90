!
! PIERNIK Code Copyright (C) 2006 Michal Hanasz
!
!    This file is part of PIERNIK code.
!
!    PIERNIK is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    PIERNIK is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with PIERNIK.  If not, see <http://www.gnu.org/licenses/>.
!
!    Initial implementation of PIERNIK code was based on TVD split MHD code by
!    Ue-Li Pen
!        see: Pen, Arras & Wong (2003) for algorithm and
!             http://www.cita.utoronto.ca/~pen/MHD
!             for original source code "mhd.f90"
!
!    For full list of developers see $PIERNIK_HOME/license/pdt.txt
!
#include "piernik.h"

!>
!! \brief In this module fluid variables of individual fluids are indexed to make use of the single array
!! \a u(:,:,:,:) containing all fluid variables.
!!
!! \par The purpose of this module is to compute:
!!
!! \n (1) positions of all fluid variables referenced through the first index of array u(:,:,:,:),
!! \n (2) %arrays of indexes to make easy reference to all gas densities, x,y,z-components of momenta,
!! energy densities, CR energy densities, transposed components of x,y,z-momenta in directional %sweeps, etc ...
!!
!! \n\b Note: Basic definitions and more information in initfluids module.
!!
!! \todo All stuff related specifically to magnetic field should be embraced
!! (everywhere in the code) with the precompiler definition "MAGNETIC" instead of "IONIZED"
!<

module fluidindex
! pulled by ANY
   use constants,  only: ndims
   use fluidtypes, only: var_numbers
#ifdef STREAM_CR
   use fluidtypes, only: var_numbers_scr
#endif /* STREAM_CR*/

   implicit none

   private :: ndims, var_numbers ! QA_WARN: prevent reexporting
   public ! QA_WARN no secrets are kept here

   type(var_numbers),save :: flind     !< COMMENT ME
   
#ifdef STREAM_CR
   type(var_numbers_scr),save :: scrind     !< COMMENT ME
#endif /* STREAM_CR*/

   integer(kind=4), parameter  :: nmag = ndims     !< number of magnetic field components

   integer(kind=4), allocatable, dimension(:) :: iarr_all_dn   !< array of indexes pointing to mass densities of all fluids
   integer(kind=4), allocatable, dimension(:) :: iarr_all_sg   !< array of indexes pointing to mass densities of all selfgravitating fluids
   integer(kind=4), allocatable, dimension(:) :: iarr_all_mx   !< array of indexes pointing to mom. densities of all fluids
   integer(kind=4), allocatable, dimension(:) :: iarr_all_my   !< array of indexes pointing to mom. densities of all fluids
   integer(kind=4), allocatable, dimension(:) :: iarr_all_mz   !< array of indexes pointing to mom. densities of all fluids
   integer(kind=4), allocatable, dimension(:) :: iarr_all_en   !< array of indexes pointing to ener. densities of all fluids
   integer(kind=4), allocatable, dimension(:) :: iarr_all_crn  !< array of indexes pointing to ener. densities of all nuclear CR-components
   integer(kind=4), allocatable, dimension(:) :: iarr_all_cre  !< array of indexes pointing to ener. densities of all electron CR-components
   integer(kind=4), allocatable, dimension(:), target :: iarr_all_crs   !< array of indexes pointing to ener. densities of all CR-components
   integer(kind=4), allocatable, dimension(:), target :: iarr_all_trc   !< array of indexes pointing to tracers
   integer(kind=4), allocatable, dimension(:,:) :: iarr_all_swp         !< array (size = flind) of all fluid indexes in the order depending on sweeps direction

   integer(kind=4), allocatable, dimension(:)   :: iarr_all_mag         !< array (size = nmag) of all magnetic field components
   integer(kind=4), allocatable, dimension(:,:) :: iarr_mag_swp         !< array (size = nmag) of all mag. field indexes in the order depending on sweeps direction

   integer(kind=4) :: i_sg                                              !< index denoting position of the selfgravitating fluid in the row of fluids - should be an iarr_sg !
   
   integer(kind=4), allocatable, dimension(:)   :: iarr_all_escr          !< array of indexes pointing to energy density of all streaming cosmic rays
   integer(kind=4), allocatable, dimension(:)   :: iarr_all_xfscr         !< array of indexes pointing to Fcx of all streaming cosmic rays
   integer(kind=4), allocatable, dimension(:)   :: iarr_all_yfscr         !< array of indexes pointing to Fcy of all streaming cosmic rays
   integer(kind=4), allocatable, dimension(:)   :: iarr_all_zfscr         !< array of indexes pointing to Fcz of all streaming cosmic rays
   integer(kind=4), allocatable, dimension(:,:) :: iarr_all_scr_swp       !< array (size = scrind) of all streaming cosmic rays indexes in the order depending on sweeps direction
   integer(kind=4), allocatable, dimension(:)   :: iarr_all_gpcx          !< array of indexes pointing to x component of ∇.Pc of all streaming cosmic rays
   integer(kind=4), allocatable, dimension(:)   :: iarr_all_gpcy          !< array of indexes pointing to y component of ∇.Pc of all streaming cosmic rays
   integer(kind=4), allocatable, dimension(:)   :: iarr_all_gpcz          !< array of indexes pointing to z component of ∇.Pc of all streaming cosmic rays
contains

   subroutine set_fluidindex_arrays(fl, have_ener)

      use constants,  only: I_ONE
      use fluidtypes, only: component_fluid

      implicit none

      class(component_fluid), intent(inout) :: fl
      logical,                intent(in)    :: have_ener

#ifdef ISO
      logical :: fnord
#endif /* ISO */

      iarr_all_swp(:,fl%beg:fl%end) = fl%iarr_swp(:,:)

      if (fl%is_selfgrav) then
         i_sg = i_sg + I_ONE
         iarr_all_sg(i_sg) = fl%idn
      endif

      iarr_all_dn(fl%pos) = fl%idn
      iarr_all_mx(fl%pos) = fl%imx
      iarr_all_my(fl%pos) = fl%imy
      iarr_all_mz(fl%pos) = fl%imz

#ifdef ISO
      if (.false.) fnord = have_ener ! suppress compiler warning on unused argument
#else /* !ISO */
      if (have_ener) iarr_all_en(fl%pos) = fl%ien
#endif /* !ISO */

   end subroutine set_fluidindex_arrays

#ifdef STREAM_CR
   subroutine set_scrindex_arrays(scr_fluid)
      
      use fluidtypes,      only: component_scr

      implicit none

       !use scr for streaming cosmic ray
      class(component_scr), intent(inout) :: scr_fluid                
      integer(kind=4),  save :: scrpos =1              ! Needed here because using scr_fluid%pos goes out of bound !

      iarr_all_escr(scrpos) = scr_fluid%iescr
      iarr_all_xfscr(scrpos) = scr_fluid%ixfscr
      iarr_all_yfscr(scrpos) = scr_fluid%iyfscr
      iarr_all_zfscr(scrpos) = scr_fluid%izfscr
      iarr_all_scr_swp(:,1 + 4 * (scrpos-1) : 4 + 4 * (scrpos-1)) = scr_fluid%iarr_scr_swp(:,:)

      scrpos = scrpos + 1
   end subroutine set_scrindex_arrays
#endif /* STREAM_CR */
!>
!! \brief Subroutine fluid_index constructing all multi-fluid indexes used in other parts of PIERNIK code
!<
   subroutine fluid_index

      use constants,      only: ndims, xdim, ydim, zdim
      use fluids_pub,     only: has_dst, has_ion, has_neu
      use initdust,       only: dust_fluid
      use initionized,    only: ion_fluid
      use initneutral,    only: neutral_fluid
#ifdef COSM_RAYS
      use initcosmicrays, only: iarr_crn, iarr_cre, iarr_crs, cosmicray_index
#endif /* COSM_RAYS */
#ifdef TRACER
      use inittracer,     only: tracer_index, iarr_trc
#endif /* TRACER */
#ifdef STREAM_CR
      use initstreamingcr,   only: nscr
#endif /* STREAM_CR */

      implicit none

      integer :: i

      i_sg = 0

      if (has_ion) then
         !  Compute indexes for the ionized fluid and update counters
         allocate(ion_fluid::flind%ion)
         call flind%ion%initialize_indices(flind)
      endif

      if (has_neu) then
         !  Compute indexes for the neutral fluid and update counters
         allocate(neutral_fluid::flind%neu)
         call flind%neu%initialize_indices(flind)
      endif

      if (has_dst) then
      !  Compute indexes for the dust fluid and update counters
         allocate(dust_fluid::flind%dst)
         call flind%dst%initialize_indices(flind)
      endif

#ifdef COSM_RAYS
!  Compute indexes for the CR component and update counters
      call cosmicray_index(flind)
#endif /* !COSM_RAYS */

#ifdef TRACER
      call tracer_index(flind)
#endif /* TRACER */

#ifdef STREAM_CR
      allocate(scrind%scr(nscr))            
      do i = 1, nscr
            call scrind%scr(i)%set_scr_index(scrind)       ! initialize scr indices for each species
      end do
#endif /* STREAM_CR */

! Allocate index arrays
      allocate(iarr_mag_swp(ndims,nmag),iarr_all_mag(nmag))
      allocate(iarr_all_swp(xdim:zdim, flind%all))
      allocate(iarr_all_dn(flind%fluids),iarr_all_mx(flind%fluids),iarr_all_my(flind%fluids),iarr_all_mz(flind%fluids))
      allocate(iarr_all_sg(flind%fluids_sg))
#ifdef ISO
      allocate(iarr_all_en(0))
#else /* !ISO */
      allocate(iarr_all_en(flind%energ))
#endif /* !ISO */

#ifdef COSM_RAYS
      allocate(iarr_all_crn(flind%crn%all))
      allocate(iarr_all_cre(flind%cre%all))
      allocate(iarr_all_crs(flind%crs%all))
#else /* !COSM_RAYS */
      allocate(iarr_all_crn(0))
      allocate(iarr_all_cre(0))
      allocate(iarr_all_crs(0))
#endif /* !COSM_RAYS */

#ifdef TRACER
      allocate(iarr_all_trc(flind%trc%all))
#else /* !TRACER */
      allocate(iarr_all_trc(0))
#endif /* !TRACER */

#ifdef STREAM_CR
      allocate(iarr_all_scr_swp(xdim:zdim, 4*nscr))
      allocate(iarr_all_escr(nscr),iarr_all_xfscr(nscr),iarr_all_yfscr(nscr),iarr_all_zfscr(nscr))
      allocate(iarr_all_gpcx(nscr),iarr_all_gpcy(nscr),iarr_all_gpcz(nscr))
#else /* !STREAM_CR */
      allocate(iarr_all_scr_swp(0, 0))
      allocate(iarr_all_escr(0),iarr_all_xfscr(0),iarr_all_yfscr(0),iarr_all_zfscr(0))
#endif /* !STREAM_CR */

      ! Compute index arrays for magnetic field
      iarr_mag_swp(xdim,:) = [xdim,ydim,zdim]
      iarr_mag_swp(ydim,:) = [ydim,xdim,zdim]
      iarr_mag_swp(zdim,:) = [zdim,ydim,xdim]
      iarr_all_mag(:)      = [xdim,ydim,zdim]

      ! Compute index arrays for the ionized fluid
      if (has_ion) call set_fluidindex_arrays(flind%ion,.true.)

      ! Compute index arrays for the neutral fluid
      if (has_neu) call set_fluidindex_arrays(flind%neu,.true.)

      ! Compute index arrays for the dust fluid
      if (has_dst) call set_fluidindex_arrays(flind%dst,.false.)

#ifdef COSM_RAYS
! Compute index arrays for the CR components
      iarr_all_swp(xdim,flind%crs%beg:flind%crs%end) = iarr_crs
      iarr_all_swp(ydim,flind%crs%beg:flind%crs%end) = iarr_crs
      iarr_all_swp(zdim,flind%crs%beg:flind%crs%end) = iarr_crs

      iarr_all_crn(1:flind%crn%all) = iarr_crn
      iarr_all_cre(1:flind%cre%all) = iarr_cre
      iarr_all_crs(1:flind%crs%all) = iarr_crs
#endif /* COSM_RAYS */

#ifdef TRACER
      iarr_all_swp(xdim,flind%trc%beg:flind%trc%end) = iarr_trc
      iarr_all_swp(ydim,flind%trc%beg:flind%trc%end) = iarr_trc
      iarr_all_swp(zdim,flind%trc%beg:flind%trc%end) = iarr_trc

      iarr_all_trc(1:flind%trc%all) = iarr_trc
#endif /* TRACER */

#ifdef STREAM_CR
      do i=1, nscr
            call set_scrindex_arrays(scrind%scr(i))
      end do
      iarr_all_gpcx = [(xdim + 3*(i-1), i=1, nscr)]
      iarr_all_gpcy = [(ydim + 3*(i-1), i=1, nscr)]
      iarr_all_gpcz = [(zdim + 3*(i-1), i=1, nscr)]      
#endif /* STREAM_CR */

      allocate(flind%all_fluids(flind%fluids))

      i = 1
      if (has_ion) then
         flind%all_fluids(i)%fl => flind%ion
         i = i + 1
      endif

      if (has_neu) then
         flind%all_fluids(i)%fl => flind%neu
         i = i + 1
      endif

      if (has_dst) then
!         allocate(dust_fluid::flind%all_fluids(i)%fl) ! = flind%dst
         flind%all_fluids(i)%fl => flind%dst
         i = i + 1
      endif
   end subroutine fluid_index

   subroutine cleanup_fluidindex

      use diagnostics, only: my_deallocate
      use fluids_pub,  only: has_ion, has_neu, has_dst

      implicit none

      integer :: i

      call my_deallocate(iarr_mag_swp)
      call my_deallocate(iarr_all_swp)
      call my_deallocate(iarr_all_mag)
      call my_deallocate(iarr_all_dn)
      call my_deallocate(iarr_all_mx)
      call my_deallocate(iarr_all_my)
      call my_deallocate(iarr_all_mz)
      call my_deallocate(iarr_all_sg)
      call my_deallocate(iarr_all_en)

      call my_deallocate(iarr_all_crn)
      call my_deallocate(iarr_all_cre)
      call my_deallocate(iarr_all_crs)

      call my_deallocate(iarr_all_trc)

#ifdef STREAM_CR
      if (allocated(iarr_all_escr)) call my_deallocate(iarr_all_escr)
      if (allocated(iarr_all_xfscr)) call my_deallocate(iarr_all_xfscr)
      if (allocated(iarr_all_yfscr)) call my_deallocate(iarr_all_yfscr)
      if (allocated(iarr_all_zfscr)) call my_deallocate(iarr_all_zfscr)
      if (allocated(iarr_all_scr_swp)) call my_deallocate(iarr_all_scr_swp)
      if (allocated(iarr_all_gpcx)) call my_deallocate(iarr_all_gpcx)
      if (allocated(iarr_all_gpcy)) call my_deallocate(iarr_all_gpcy)
      if (allocated(iarr_all_gpcz)) call my_deallocate(iarr_all_gpcz)
#endif /* STREAM_CR */

      do i = lbound(flind%all_fluids, dim=1), ubound(flind%all_fluids, dim=1)
         deallocate(flind%all_fluids(i)%fl%iarr)
         deallocate(flind%all_fluids(i)%fl%iarr_swp)
      enddo
      deallocate(flind%all_fluids)
      if (has_ion) deallocate(flind%ion) ! cannot check if allocated, because it is not allocatable
      if (has_neu) deallocate(flind%neu)
      if (has_dst) deallocate(flind%dst)

   end subroutine cleanup_fluidindex

end module fluidindex
